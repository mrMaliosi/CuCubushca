package ru.nsu.ccfit.malinovskii.Controller;

import javafx.beans.property.SimpleStringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.chart.PieChart;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.stage.Modality;
import javafx.stage.Stage;
import ru.nsu.ccfit.malinovskii.Model.Objects.Context;
import ru.nsu.ccfit.malinovskii.Model.Objects.Subject;
import ru.nsu.ccfit.malinovskii.Model.Objects.Task;
import ru.nsu.ccfit.malinovskii.Model.Objects.Workspace;

import java.io.IOException;
import java.net.URL;
import java.util.List;

import static ru.nsu.ccfit.malinovskii.Model.CuCubushca.fm;
import static ru.nsu.ccfit.malinovskii.Model.Objects.Context.getContext;

public class WorkspaceController {
    @FXML
    private VBox workspaceContainer; // Контейнер для размещения всех TableView
    @FXML
    private Button createSubjectButton; // Кнопка для создания нового предмета
    @FXML
    private ScrollPane scrollPane; // ScrollPane для прокрутки

    private Workspace workspace;  // Текущая рабочая область
    Context context = getContext();

    private int rowPos = -1;  // Переменная для хранения позиции строки
    private int columnPos = -1;  // Переменная для хранения позиции столбца

    private void createTable(String subjectName, List<Task> tasks) {
        // Создание HBox для размещения таблицы и диаграммы рядом
        HBox tableAndChartContainer = new HBox(20); // Отступ между таблицей и диаграммой
        tableAndChartContainer.setAlignment(Pos.CENTER_LEFT); // Выравнивание по центру

        // Создание TableView
        TableView<ObservableList<String>> tableView = new TableView<>();
        tableView.setMaxWidth(400);  // Максимальная ширина таблицы
        tableView.setMaxHeight(160); // Максимальная высота таблицы

        // Столбец для предмета
        TableColumn<ObservableList<String>, String> subjectColumn = new TableColumn<>(subjectName);
        subjectColumn.setCellValueFactory(param -> new SimpleStringProperty(param.getValue().get(0)));  // Первая ячейка строки
        tableView.getColumns().add(subjectColumn);

        // Создание столбцов для каждой задачи
        for (Task task : tasks) {
            TableColumn<ObservableList<String>, String> taskColumn = new TableColumn<>(task.getName());
            taskColumn.setCellFactory(col -> new TableCell<ObservableList<String>, String>() {
                @Override
                protected void updateItem(String item, boolean empty) {
                    super.updateItem(item, empty);
                    setText(item);
                    setStyle("-fx-font-size: 24px; -fx-background-color: white;");  // Устанавливаем размер шрифта и фон
                    setAlignment(Pos.CENTER);

                    // Обработчик клика
                    setOnMouseClicked(event -> {
                        handleCellClick(this, getIndex(), getTableColumn());  // Обрабатываем клик
                        while (rowPos >= 0) {
                            --rowPos;
                            // обновить стиль для ячейки на rowPos и columnPos
                        }
                    });
                }
            });
            tableView.getColumns().add(taskColumn);  // Добавляем столбец для каждой задачи
        }

        // Заполняем строки данными
        for (int i = 0; i < 3; i++) {
            ObservableList<String> row = FXCollections.observableArrayList();
            switch (i) {
                case 0:
                    row.add("Начато");
                    break;
                case 1:
                    row.add("Уже близко");
                    break;
                case 2:
                    row.add("Готово");
                    break;
            }

            for (int j = 0; j < tasks.size(); j++) {
                // Добавляем пустое значение или начальное значение для каждой задачи
                row.add("");  // Пустые значения
            }

            tableView.getItems().add(row);  // Добавляем строку в таблицу
        }

        // Добавляем таблицу в контейнер
        tableAndChartContainer.getChildren().add(tableView);

        // Создание круговой диаграммы (PieChart)
        PieChart pieChart = createPieChart(tasks);
        tableAndChartContainer.getChildren().add(pieChart);  // Добавляем диаграмму рядом с таблицей

        // Добавляем контейнер с таблицей и диаграммой в основной контейнер
        workspaceContainer.getChildren().add(tableAndChartContainer);
    }

    private PieChart createPieChart(List<Task> tasks) {
        int tasksStarted = 0;
        int tasksAlmost = 0;
        int tasksReady = 0;

        for (Task task : tasks) {
            switch (task.getStatus()){
                case IN_WORK -> ++tasksAlmost;
                case PASS -> ++tasksReady;
                default -> ++tasksStarted;
            }
        }
        int tasksAll = tasksStarted + tasksAlmost + tasksReady;

        PieChart.Data slice1 = new PieChart.Data("Начато", (double)tasksStarted/tasksAll);
        PieChart.Data slice2 = new PieChart.Data("Уже близко", (double)tasksAlmost/tasksAll);
        PieChart.Data slice3 = new PieChart.Data("Готово", (double)tasksReady/tasksAll);

        PieChart pieChart = new PieChart();
        pieChart.getData().addAll(slice1, slice2, slice3);
        pieChart.setMaxWidth(200);  // Ограничиваем ширину диаграммы
        pieChart.setMaxHeight(200); // Ограничиваем высоту диаграммы
        pieChart.setLegendVisible(true); // Отображение легенды диаграммы

        return pieChart;
    }

    // Обработчик клика по ячейке
    private void handleCellClick(TableCell<ObservableList<String>, String> cell, int rowIdx, TableColumn<ObservableList<String>, String> column) {
        int columnIdx = column.getTableView().getColumns().indexOf(column);
        cell.setStyle("-fx-background-color: lightgreen; -fx-font-size: 24px;");
        --rowIdx;
        rowPos = rowIdx;
        columnPos = columnIdx;
    }

    // Метод для установки текущей рабочей области
    public void setWorkspace(Workspace workspace) {
        this.workspace = workspace;
        initializeWorkspace();
    }

    // Метод для инициализации рабочего пространства
    public void initializeWorkspace() {
        List<String> subjectNames = workspace.getSubjectNames();

        for (String subjectName : subjectNames) {
            List<Task> tasks = workspace.getSubjectTasks(subjectName);
            createTable(subjectName, tasks);
        }
    }

    // Обработчик для создания нового предмета
    @FXML
    private void handleCreateSubject() {
        try {
            URL motivationXmlUrl = getClass().getResource("/ru/nsu/ccfit/malinovskii/view/subject-creation-view.fxml");
            FXMLLoader loader = new FXMLLoader(motivationXmlUrl);
            Parent root = loader.load();

            // Получаем контроллер из FXML
            SubjectCreationController controller = loader.getController();

            // Создаём новое окно (Stage)
            Stage stage = new Stage();
            stage.setTitle("Создание предмета");
            stage.setScene(new Scene(root));
            stage.initModality(Modality.APPLICATION_MODAL); // Модальное окно, блокирует остальные окна до закрытия
            stage.showAndWait(); // Ждём закрытия окна

            // Получаем имя рабочего пространства, которое было введено в окне
            String newName = controller.getSubjectName();
            int tasksNumber = controller.getTasksNumber();

            // Если имя было введено, добавляем рабочую область в контекст
            if (newName != null && !newName.isEmpty()) {
                Subject newSubject = new Subject(newName);
                for (int i = 1; i <= tasksNumber; ++i) {
                    newSubject.addTaskByName(String.valueOf(i));
                }
                workspace.addSubject(newSubject);
                fm.save(context.getWorkspaces());

                createTable(newSubject.getName(), newSubject.getTasksList()); // Создаем таблицу для нового предмета
            } else {
                System.out.println("Имя рабочей области не может быть пустым!");
            }
        } catch (IOException ex) {
            // Обработка ошибок при загрузке FXML
            ex.printStackTrace();
        }
    }
}
